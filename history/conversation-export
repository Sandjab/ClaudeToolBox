#!/bin/bash
# conversation-export - Outil d'export de conversations Claude Code
# Permet de naviguer et exporter les conversations en Markdown

set -euo pipefail

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Couleurs et constantes
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

CLAUDE_DIR="$HOME/.claude/projects"
VERSION="1.3.1"

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Fonctions utilitaires
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
info() { echo -e "${GREEN}[INFO]${NC} $1"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $1" >&2; }
error() { echo -e "${RED}[ERREUR]${NC} $1" >&2; exit 1; }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# VÃ©rification des dÃ©pendances
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
check_dependencies() {
    if ! command -v jq &>/dev/null; then
        error "jq est requis. Installez-le avec: brew install jq"
    fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Aide
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
show_help() {
    cat << EOF
${BOLD}conversation-export${NC} - Export de conversations Claude Code

${BOLD}USAGE${NC}
    conversation-export [OPTIONS]

${BOLD}OPTIONS${NC}
    (aucune)            Mode interactif (fzf si disponible, sinon TUI)
    -l, --list          Liste les conversations (sans interactivitÃ©)
    -e, --export <id>   Exporte directement la conversation #id
    -o, --output <file> Fichier de sortie (dÃ©faut: <slug>.md ou stdout)
    -f, --format <fmt>  Format de sortie: md ou html (dÃ©faut: md)
    --with-code         Inclut les blocs de code (dÃ©faut: texte seul)
    --project <name>    Filtre par nom de projet
    --no-fzf            Force le TUI intÃ©grÃ© (dÃ©sactive fzf)
    --max-output-lines <N>  Limite de lignes pour les outputs (dÃ©faut: 30)
    --include-agents    Inclure les rÃ©sultats d'agents (dÃ©faut: exclus)
    --show-outputs      Afficher les outputs (dÃ©faut: masquÃ©s avec "...")
    -h, --help          Affiche cette aide
    -v, --version       Affiche la version

${BOLD}EXEMPLES${NC}
    conversation-export              # Mode interactif
    conversation-export -l           # Liste toutes les conversations
    conversation-export -e 3         # Exporte la conversation #3
    conversation-export -e 1 -o conv.md --with-code
    conversation-export -e 1 --max-output-lines 50 --include-agents
    conversation-export -e 1 -f html -o conversation.html  # Export HTML

${BOLD}FORMAT DE SORTIE${NC}
    Le fichier Markdown gÃ©nÃ©rÃ© contient :
    - Titre (slug ou premier message)
    - MÃ©tadonnÃ©es (projet, date)
    - Messages utilisateur en bloc [!CAUTION]
    - RÃ©ponses Claude en bloc [!NOTE]
    - Outputs masquÃ©s par dÃ©faut (--show-outputs pour afficher)

EOF
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Extraction du nom de projet depuis le chemin encodÃ©
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
decode_project_name() {
    local encoded_path="$1"
    # Le chemin est encodÃ© avec des tirets remplaÃ§ant les /
    # Ex: -Users-jean-paul-ClaudeToolBox -> ClaudeToolBox
    local decoded
    decoded=$(echo "$encoded_path" | sed 's/-/\//g')
    # Extraire le dernier composant (nom du projet)
    basename "$decoded"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Extraction des informations d'une conversation
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
get_conversation_info() {
    local jsonl_file="$1"
    local project_dir
    project_dir=$(dirname "$jsonl_file")
    project_dir=$(basename "$project_dir")

    local project_name
    project_name=$(decode_project_name "$project_dir")

    # Extraire le timestamp depuis les entrÃ©es user ou progress (pas file-history-snapshot)
    local timestamp
    timestamp=$(grep -m1 '"type":"user"\|"type":"progress"' "$jsonl_file" 2>/dev/null | jq -r '.timestamp // empty' 2>/dev/null || echo "")
    local date_str="inconnu"
    if [[ -n "$timestamp" && "$timestamp" != "null" ]]; then
        date_str=$(echo "$timestamp" | cut -d'T' -f1)
    fi

    # Chercher le slug dans les entrÃ©es (peut Ãªtre dans progress ou user)
    local slug
    slug=$(grep -m1 '"slug":' "$jsonl_file" 2>/dev/null | jq -r '.slug // empty' 2>/dev/null | head -1 || echo "")

    # Si pas de slug, prendre le dÃ©but du premier message utilisateur
    local title="$slug"
    if [[ -z "$title" || "$title" == "null" ]]; then
        local first_user_msg
        first_user_msg=$(grep '"type":"user"' "$jsonl_file" 2>/dev/null | head -1 || echo "")
        if [[ -n "$first_user_msg" ]]; then
            # Extraire le contenu du message
            local content
            content=$(echo "$first_user_msg" | jq -r '
                if .message.content | type == "string" then
                    .message.content
                elif .message.content | type == "array" then
                    [.message.content[] | select(.type == "text") | .text] | first // ""
                else
                    ""
                end
            ' 2>/dev/null || echo "")
            # Supprimer les balises XML type <local-command-caveat>
            content=$(echo "$content" | sed 's/<[^>]*>//g')
            # Nettoyer les espaces multiples
            content=$(echo "$content" | tr -s ' ' | sed 's/^ *//')
            # Tronquer Ã  40 caractÃ¨res
            title=$(echo "$content" | tr '\n' ' ' | cut -c1-40)
            [[ ${#content} -gt 40 ]] && title="${title}..."
        fi
    fi

    [[ -z "$title" ]] && title="(sans titre)"

    # Retourner: fichier|date|projet|titre
    echo "${jsonl_file}|${date_str}|${project_name}|${title}"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Liste toutes les conversations
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
list_conversations() {
    local project_filter="${1:-}"
    local conversations=()

    if [[ ! -d "$CLAUDE_DIR" ]]; then
        error "RÃ©pertoire Claude Code non trouvÃ©: $CLAUDE_DIR"
    fi

    # Trouver tous les fichiers .jsonl
    while IFS= read -r -d '' jsonl_file; do
        local info
        info=$(get_conversation_info "$jsonl_file")

        # Filtrer par projet si demandÃ©
        if [[ -n "$project_filter" ]]; then
            local proj
            proj=$(echo "$info" | cut -d'|' -f3)
            if [[ "$proj" != *"$project_filter"* ]]; then
                continue
            fi
        fi

        conversations+=("$info")
    done < <(find "$CLAUDE_DIR" -name "*.jsonl" -type f -print0 2>/dev/null | sort -z)

    # Trier par date dÃ©croissante (plus rÃ©cent en premier)
    IFS=$'\n' conversations=($(printf '%s\n' "${conversations[@]}" | sort -t'|' -k2 -r))
    unset IFS

    printf '%s\n' "${conversations[@]}"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Affichage formatÃ© de la liste
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
print_conversation_list() {
    local -a conversations=("$@")
    local count=${#conversations[@]}

    echo -e "\n${BOLD}Conversations Claude Code${NC} (${count} trouvÃ©es)"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    printf "${DIM}  # â”‚ Date       â”‚ Projet              â”‚ Titre${NC}\n"
    echo "â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

    local i=1
    for conv in "${conversations[@]}"; do
        local date proj title
        date=$(echo "$conv" | cut -d'|' -f2)
        proj=$(echo "$conv" | cut -d'|' -f3)
        title=$(echo "$conv" | cut -d'|' -f4)

        # Tronquer projet et titre si nÃ©cessaire
        [[ ${#proj} -gt 19 ]] && proj="${proj:0:16}..."
        [[ ${#title} -gt 34 ]] && title="${title:0:31}..."

        printf "%3d â”‚ %-10s â”‚ %-19s â”‚ %s\n" "$i" "$date" "$proj" "$title"
        ((i++))
    done
    echo ""
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TUI interactif avec navigation flÃ¨ches
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
interactive_select() {
    local -a conversations=("$@")
    local count=${#conversations[@]}
    local selected=0
    local visible_start=0
    local visible_count=15  # Nombre de lignes visibles

    if [[ $count -eq 0 ]]; then
        warn "Aucune conversation trouvÃ©e."
        return 1
    fi

    # Sauvegarder les paramÃ¨tres du terminal
    local old_tty_settings
    old_tty_settings=$(stty -g)

    # Fonction de nettoyage
    cleanup() {
        stty "$old_tty_settings"
        tput cnorm  # Afficher le curseur
        echo ""
    }
    trap cleanup EXIT

    # Masquer le curseur
    tput civis

    # Boucle principale
    while true; do
        # Effacer l'Ã©cran et positionner en haut
        clear

        echo -e "${BOLD}Conversations Claude Code${NC} (${count} trouvÃ©es)"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        printf "${DIM}  # â”‚ Date       â”‚ Projet              â”‚ Titre${NC}\n"
        echo "â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

        # Ajuster la fenÃªtre visible
        if [[ $selected -lt $visible_start ]]; then
            visible_start=$selected
        elif [[ $selected -ge $((visible_start + visible_count)) ]]; then
            visible_start=$((selected - visible_count + 1))
        fi

        # Afficher les conversations visibles
        local end=$((visible_start + visible_count))
        [[ $end -gt $count ]] && end=$count

        for ((i = visible_start; i < end; i++)); do
            local conv="${conversations[$i]}"
            local date proj title
            date=$(echo "$conv" | cut -d'|' -f2)
            proj=$(echo "$conv" | cut -d'|' -f3)
            title=$(echo "$conv" | cut -d'|' -f4)

            # Tronquer si nÃ©cessaire
            [[ ${#proj} -gt 19 ]] && proj="${proj:0:16}..."
            [[ ${#title} -gt 34 ]] && title="${title:0:31}..."

            local num=$((i + 1))
            if [[ $i -eq $selected ]]; then
                # Ligne sÃ©lectionnÃ©e
                echo -e "${CYAN}${BOLD}â–¶${NC} ${CYAN}${num}${NC} â”‚ ${CYAN}${date}${NC} â”‚ ${CYAN}${proj}${NC} â”‚ ${CYAN}${BOLD}${title}${NC}"
            else
                printf "  %d â”‚ %-10s â”‚ %-19s â”‚ %s\n" "$num" "$date" "$proj" "$title"
            fi
        done

        # Indicateurs de scroll
        if [[ $visible_start -gt 0 ]]; then
            echo -e "${DIM}  â†‘ (plus de conversations au-dessus)${NC}"
        fi
        if [[ $end -lt $count ]]; then
            echo -e "${DIM}  â†“ (plus de conversations en-dessous)${NC}"
        fi

        echo ""
        echo -e "${DIM}[â†‘/â†“] Naviguer  [Enter] Exporter  [q] Quitter${NC}"

        # Lire une touche
        stty raw -echo
        local key
        key=$(dd bs=3 count=1 2>/dev/null)
        stty "$old_tty_settings"

        case "$key" in
            $'\x1b[A'|k)  # FlÃ¨che haut ou k
                ((selected > 0)) && ((selected--))
                ;;
            $'\x1b[B'|j)  # FlÃ¨che bas ou j
                ((selected < count - 1)) && ((selected++))
                ;;
            $'\x1b[5~')  # Page Up
                ((selected -= visible_count))
                ((selected < 0)) && selected=0
                ;;
            $'\x1b[6~')  # Page Down
                ((selected += visible_count))
                ((selected >= count)) && selected=$((count - 1))
                ;;
            ''|$'\n')  # Enter
                # Retourner le fichier sÃ©lectionnÃ©
                echo "${conversations[$selected]}" | cut -d'|' -f1
                return 0
                ;;
            q|Q)  # Quitter
                return 1
                ;;
        esac
    done
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# SÃ©lection avec fzf (recherche floue)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
fzf_select() {
    local -a conversations=("$@")
    local count=${#conversations[@]}

    if [[ $count -eq 0 ]]; then
        warn "Aucune conversation trouvÃ©e."
        return 1
    fi

    # Construire la liste formatÃ©e pour fzf
    local -a formatted=()
    local i=1
    for conv in "${conversations[@]}"; do
        local date proj title
        date=$(echo "$conv" | cut -d'|' -f2)
        proj=$(echo "$conv" | cut -d'|' -f3)
        title=$(echo "$conv" | cut -d'|' -f4)

        # Tronquer si nÃ©cessaire
        [[ ${#proj} -gt 19 ]] && proj="${proj:0:16}..."
        [[ ${#title} -gt 40 ]] && title="${title:0:37}..."

        formatted+=("$(printf "%3d â”‚ %-10s â”‚ %-19s â”‚ %s" "$i" "$date" "$proj" "$title")")
        ((i++))
    done

    # Lancer fzf avec les options de prÃ©sentation
    local selection
    selection=$(printf '%s\n' "${formatted[@]}" | fzf \
        --height=80% \
        --layout=reverse \
        --border \
        --header="Conversations Claude Code (${count} trouvÃ©es) - Tapez pour filtrer" \
        --prompt="â¯ " \
        --pointer="â–¶" \
        --marker="â—" \
        --ansi \
        --no-mouse \
        --bind='ctrl-c:abort' \
        --preview-window=hidden \
    ) || return 1

    # Extraire le numÃ©ro de la sÃ©lection
    local selected_num
    selected_num=$(echo "$selection" | awk '{print $1}')

    # Valider et retourner le fichier correspondant
    if [[ -n "$selected_num" && "$selected_num" =~ ^[0-9]+$ ]]; then
        local idx=$((selected_num - 1))
        echo "${conversations[$idx]}" | cut -d'|' -f1
        return 0
    fi

    return 1
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DÃ©tection des rÃ©sultats d'agents
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
is_agent_result() {
    local content="$1"
    local line_count
    line_count=$(printf '%s' "$content" | wc -l | tr -d '[:space:]')

    # Assurer que line_count est un nombre valide
    [[ -z "$line_count" || ! "$line_count" =~ ^[0-9]+$ ]] && line_count=0

    # Patterns typiques des rapports d'agents (rapport structurÃ© avec headers Markdown)
    if [[ $line_count -gt 20 ]]; then
        # VÃ©rifie si Ã§a commence par un header markdown ou sÃ©parateur
        if [[ "$content" =~ ^(#+[[:space:]]|---|\*\*[A-Z]) ]]; then
            return 0  # C'est probablement un agent
        fi
        # VÃ©rifie la prÃ©sence de multiples headers (signe d'un rapport structurÃ©)
        local header_count
        header_count=$(printf '%s' "$content" | grep -c '^#' 2>/dev/null || echo "0")
        header_count=$(echo "$header_count" | tr -d '[:space:]')
        [[ -z "$header_count" || ! "$header_count" =~ ^[0-9]+$ ]] && header_count=0
        if [[ $header_count -gt 3 ]]; then
            return 0
        fi
    fi
    return 1
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Troncature des contenus volumineux
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
truncate_content() {
    local content="$1"
    local max_lines="${2:-30}"
    local line_count
    line_count=$(printf '%s' "$content" | wc -l | tr -d '[:space:]')

    # Assurer que line_count est un nombre valide
    [[ -z "$line_count" || ! "$line_count" =~ ^[0-9]+$ ]] && line_count=0

    if [[ $max_lines -gt 0 && $line_count -gt $max_lines ]]; then
        local head_lines=10
        local tail_lines=5
        local truncated=$((line_count - head_lines - tail_lines))
        printf '%s' "$content" | head -n $head_lines
        echo ""
        echo "[... $truncated lignes tronquÃ©es ...]"
        echo ""
        printf '%s' "$content" | tail -n $tail_lines
    else
        printf '%s\n' "$content"
    fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DÃ©tection des tool_results dans un message
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
has_tool_result() {
    local message="$1"
    echo "$message" | jq -e '.message.content | type == "array" and any(.[]; .type == "tool_result")' &>/dev/null
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Extraction et formatage du contenu d'un message
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
extract_text_content() {
    local message="$1"
    local with_code="${2:-false}"

    # Le contenu peut Ãªtre une string ou un array
    local content
    content=$(echo "$message" | jq -r '
        if .message.content | type == "string" then
            .message.content
        elif .message.content | type == "array" then
            [.message.content[] |
                if .type == "text" then
                    .text
                elif .type == "tool_result" then
                    if .content | type == "string" then
                        .content
                    elif .content | type == "array" then
                        [.content[] | select(.type == "text") | .text] | join("\n")
                    else
                        empty
                    end
                else
                    empty
                end
            ] | join("\n")
        else
            empty
        end
    ' 2>/dev/null || echo "")

    if [[ "$with_code" == "false" ]]; then
        # Supprimer les blocs de code mais garder les inline code
        # On supprime les blocs ``` ... ``` sur plusieurs lignes
        content=$(echo "$content" | perl -0777 -pe 's/```[a-z]*\n[\s\S]*?```//g' 2>/dev/null || echo "$content")
    fi

    # Nettoyer les lignes vides multiples
    content=$(echo "$content" | sed '/^$/N;/^\n$/d')

    echo "$content"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Template CSS pour export HTML (style chat)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
get_html_css() {
    cat << 'CSSEOF'
@page {
    size: A4;
    margin: 2cm;
}
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    font-size: 11pt;
    line-height: 1.5;
    color: #333;
    background: #fff;
    max-width: 100%;
}
.header {
    text-align: center;
    margin-bottom: 2em;
    padding-bottom: 1em;
    border-bottom: 2px solid #e0e0e0;
}
.header h1 {
    font-size: 18pt;
    margin: 0 0 0.5em 0;
    color: #1a1a1a;
}
.header .meta {
    font-size: 10pt;
    color: #666;
}
.conversation {
    display: flex;
    flex-direction: column;
    gap: 1em;
}
.message {
    max-width: 80%;
    padding: 0.8em 1em;
    border-radius: 12px;
    position: relative;
}
.message.user {
    align-self: flex-start;
    background: #DCF8C6;
    border-bottom-left-radius: 4px;
    margin-right: auto;
}
.message.assistant {
    align-self: flex-end;
    background: #E3F2FD;
    border-bottom-right-radius: 4px;
    margin-left: auto;
}
.message .role {
    font-size: 9pt;
    font-weight: 600;
    margin-bottom: 0.3em;
    color: #555;
}
.message.user .role {
    color: #2E7D32;
}
.message.assistant .role {
    color: #1565C0;
}
.message .content {
    white-space: pre-wrap;
    word-wrap: break-word;
}
.message code {
    background: rgba(0,0,0,0.06);
    padding: 0.1em 0.3em;
    border-radius: 3px;
    font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    font-size: 10pt;
}
.message pre {
    background: #f5f5f5;
    padding: 0.8em;
    border-radius: 6px;
    overflow-x: auto;
    font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    font-size: 9pt;
}
CSSEOF
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Ã‰chapper les caractÃ¨res HTML
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
escape_html() {
    local text="$1"
    # Supprimer les octets nuls et caractÃ¨res de contrÃ´le problÃ©matiques
    text=$(printf '%s' "$text" | tr -d '\000\001\002\003\004\005\006\007\010\013\014\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037')
    text="${text//&/&amp;}"
    text="${text//</&lt;}"
    text="${text//>/&gt;}"
    text="${text//\"/&quot;}"
    text="${text//\\/&#92;}"
    printf '%s' "$text"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Export d'une conversation en HTML
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export_conversation_html() {
    local jsonl_file="$1"
    local output_file="${2:-}"
    local with_code="${3:-false}"

    if [[ ! -f "$jsonl_file" ]]; then
        error "Fichier non trouvÃ©: $jsonl_file"
    fi

    # Extraire les mÃ©tadonnÃ©es
    local info
    info=$(get_conversation_info "$jsonl_file")
    local date_str proj title
    date_str=$(echo "$info" | cut -d'|' -f2)
    proj=$(echo "$info" | cut -d'|' -f3)
    title=$(echo "$info" | cut -d'|' -f4)

    # GÃ©nÃ©rer le nom de fichier si non spÃ©cifiÃ©
    if [[ -z "$output_file" ]]; then
        local safe_title
        safe_title=$(echo "$title" | tr -cd '[:alnum:]-_' | cut -c1-50)
        [[ -z "$safe_title" ]] && safe_title="conversation"
        output_file="${safe_title}.html"
    fi

    # Construire le HTML
    local html_content=""
    html_content+='<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>'"$(escape_html "$title")"'</title>
<style>
'"$(get_html_css)"'
</style>
</head>
<body>
<div class="header">
<h1>'"$(escape_html "$title")"'</h1>
<div class="meta">Projet: '"$(escape_html "$proj")"' &bull; Date: '"${date_str}"'</div>
</div>
<div class="conversation">
'

    # Lire et traiter les messages
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        local msg_type role
        msg_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null || echo "")
        role=$(echo "$line" | jq -r '.message.role // empty' 2>/dev/null || echo "")

        # Ne traiter que les messages user et assistant
        if [[ "$msg_type" != "user" && "$msg_type" != "assistant" ]]; then
            continue
        fi

        # Ignorer les tool_result (outputs) complÃ¨tement pour le PDF
        if has_tool_result "$line"; then
            continue
        fi

        # Extraire le contenu texte
        local content
        content=$(extract_text_content "$line" "$with_code")

        # Ignorer les messages vides
        [[ -z "$content" || "$content" =~ ^[[:space:]]*$ ]] && continue

        # Ignorer les messages internes/systÃ¨me
        if [[ "$content" =~ ^\<local-command || "$content" =~ ^\<command-name || \
              "$content" =~ ^\[Request\ interrupted || "$content" =~ ^\<local-command-stdout || \
              "$content" =~ ^Implement\ the\ following\ plan ]]; then
            continue
        fi

        # Ã‰chapper le HTML et formater
        local escaped_content
        escaped_content=$(escape_html "$content")

        # Convertir les blocs de code markdown en HTML si prÃ©sents
        if [[ "$with_code" == "true" ]]; then
            escaped_content=$(echo "$escaped_content" | sed 's/```\([a-z]*\)/<pre><code>/g; s/```/<\/code><\/pre>/g')
        fi

        # Ajouter le message
        if [[ "$role" == "user" ]]; then
            html_content+='<div class="message user">
<div class="role">ðŸ‘¤ Utilisateur</div>
<div class="content">'"${escaped_content}"'</div>
</div>
'
        elif [[ "$role" == "assistant" ]]; then
            html_content+='<div class="message assistant">
<div class="role">ðŸ¤– Claude</div>
<div class="content">'"${escaped_content}"'</div>
</div>
'
        fi
    done < "$jsonl_file"

    html_content+='</div>
</body>
</html>'

    # Ã‰crire le fichier HTML (en filtrant les octets nuls)
    printf '%s' "$html_content" | tr -d '\000' > "$output_file"
    info "Conversation exportÃ©e vers: ${output_file}"
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Export d'une conversation en Markdown
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export_conversation() {
    local jsonl_file="$1"
    local output_file="${2:-}"
    local with_code="${3:-false}"
    local max_output_lines="${4:-30}"
    local include_agents="${5:-false}"
    local show_outputs="${6:-false}"

    if [[ ! -f "$jsonl_file" ]]; then
        error "Fichier non trouvÃ©: $jsonl_file"
    fi

    # Extraire les mÃ©tadonnÃ©es
    local info
    info=$(get_conversation_info "$jsonl_file")
    local date_str proj title
    date_str=$(echo "$info" | cut -d'|' -f2)
    proj=$(echo "$info" | cut -d'|' -f3)
    title=$(echo "$info" | cut -d'|' -f4)

    # GÃ©nÃ©rer le nom de fichier si non spÃ©cifiÃ©
    if [[ -z "$output_file" ]]; then
        local safe_title
        safe_title=$(echo "$title" | tr -cd '[:alnum:]-_' | cut -c1-50)
        [[ -z "$safe_title" ]] && safe_title="conversation"
        output_file="${safe_title}.md"
    fi

    # GÃ©nÃ©rer le contenu Markdown
    local md_content=""
    md_content+='# Conversation: '"${title}"'

**Projet**: '"${proj}"'
**Date**: '"${date_str}"'

---

'

    # Buffer pour merger les rÃ©ponses Claude et outputs consÃ©cutifs
    local note_buffer=""

    # Lire et traiter les messages
    while IFS= read -r line; do
        # Ignorer les lignes vides
        [[ -z "$line" ]] && continue

        # Extraire le type et le rÃ´le
        local msg_type role
        msg_type=$(echo "$line" | jq -r '.type // empty' 2>/dev/null || echo "")
        role=$(echo "$line" | jq -r '.message.role // empty' 2>/dev/null || echo "")

        # Ne traiter que les messages user et assistant
        if [[ "$msg_type" != "user" && "$msg_type" != "assistant" ]]; then
            continue
        fi

        # Extraire le contenu texte
        local content
        content=$(extract_text_content "$line" "$with_code")

        # Ignorer les messages vides
        [[ -z "$content" || "$content" =~ ^[[:space:]]*$ ]] && continue

        # Ignorer les messages internes/systÃ¨me
        if [[ "$content" =~ ^\<local-command || "$content" =~ ^\<command-name || \
              "$content" =~ ^\[Request\ interrupted || "$content" =~ ^\<local-command-stdout || \
              "$content" =~ ^Implement\ the\ following\ plan ]]; then
            continue
        fi

        # Formater selon le rÃ´le
        if [[ "$role" == "user" ]]; then
            # VÃ©rifier si c'est un tool_result
            if has_tool_result "$line"; then
                # VÃ©rifier si c'est un rÃ©sultat d'agent
                if is_agent_result "$content"; then
                    if [[ "$include_agents" != "true" ]]; then
                        # Exclure les rÃ©sultats d'agents (sauf si --include-agents)
                        continue
                    fi
                fi

                # Ajouter l'output dans le note_buffer (intÃ©grÃ© au tour de Claude)
                if [[ "$show_outputs" == "true" ]]; then
                    if [[ -n "$note_buffer" ]]; then
                        note_buffer+=$'\n\n'
                    fi
                    local truncated_output
                    truncated_output=$(truncate_content "$content" "$max_output_lines")
                    note_buffer+='```'$'\n'"${truncated_output}"$'\n''```'
                else
                    # Ne pas ajouter "..." si le buffer se termine dÃ©jÃ  par "..."
                    if [[ ! "$note_buffer" =~ \.\.\.$ ]]; then
                        if [[ -n "$note_buffer" ]]; then
                            note_buffer+=$'\n\n'
                        fi
                        note_buffer+="..."
                    fi
                fi
            else
                # Flush les notes accumulÃ©es avant le message utilisateur
                if [[ -n "$note_buffer" ]]; then
                    local quoted_notes
                    quoted_notes=$(printf '%s' "$note_buffer" | sed 's/^/> /')
                    md_content+='
> [!NOTE]
'"${quoted_notes}"'
'
                    note_buffer=""
                fi

                # Message utilisateur en bloc CAUTION avec texte en H4
                local quoted_content
                quoted_content=$(printf '%s' "$content" | sed 's/^/> #### /')
                md_content+='
> [!CAUTION]
'"${quoted_content}"'
'
            fi
        elif [[ "$role" == "assistant" ]]; then
            # Accumuler la rÃ©ponse Claude dans le buffer
            if [[ -n "$note_buffer" ]]; then
                note_buffer+=$'\n\n'
            fi
            note_buffer+="$content"
        fi
    done < "$jsonl_file"

    # Flush final si notes restantes
    if [[ -n "$note_buffer" ]]; then
        local quoted_notes
        quoted_notes=$(printf '%s' "$note_buffer" | sed 's/^/> /')
        md_content+='
> [!NOTE]
'"${quoted_notes}"'
'
    fi

    # Ã‰crire le fichier
    if [[ "$output_file" == "-" ]]; then
        printf '%s' "$md_content"
    else
        printf '%s' "$md_content" > "$output_file"
        info "Conversation exportÃ©e vers: ${output_file}"
    fi
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Parsing des arguments
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
parse_args() {
    MODE="interactive"
    EXPORT_ID=""
    OUTPUT_FILE=""
    OUTPUT_FORMAT="md"      # md ou html
    WITH_CODE="false"
    PROJECT_FILTER=""
    USE_FZF="auto"  # auto, true, false
    MAX_OUTPUT_LINES="30"  # Limite de lignes pour outputs
    INCLUDE_AGENTS="false"  # Inclure rÃ©sultats d'agents
    SHOW_OUTPUTS="false"    # Afficher les outputs (sinon ...)

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                echo "conversation-export version $VERSION"
                exit 0
                ;;
            -l|--list)
                MODE="list"
                shift
                ;;
            -e|--export)
                MODE="export"
                if [[ -z "${2:-}" || "$2" =~ ^- ]]; then
                    error "L'option -e/--export nÃ©cessite un numÃ©ro de conversation"
                fi
                # Valider que c'est un nombre
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    error "L'identifiant de conversation doit Ãªtre un nombre"
                fi
                EXPORT_ID="$2"
                shift 2
                ;;
            -o|--output)
                if [[ -z "${2:-}" || "$2" =~ ^- ]]; then
                    error "L'option -o/--output nÃ©cessite un nom de fichier"
                fi
                OUTPUT_FILE="$2"
                shift 2
                ;;
            -f|--format)
                if [[ -z "${2:-}" || "$2" =~ ^- ]]; then
                    error "L'option -f/--format nÃ©cessite un format (md ou html)"
                fi
                if [[ "$2" != "md" && "$2" != "html" ]]; then
                    error "Format invalide: $2. Utilisez 'md' ou 'html'"
                fi
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            --with-code)
                WITH_CODE="true"
                shift
                ;;
            --project)
                if [[ -z "${2:-}" || "$2" =~ ^- ]]; then
                    error "L'option --project nÃ©cessite un nom de projet"
                fi
                PROJECT_FILTER="$2"
                shift 2
                ;;
            --no-fzf)
                USE_FZF="false"
                shift
                ;;
            --max-output-lines)
                if [[ -z "${2:-}" || "$2" =~ ^- ]]; then
                    error "L'option --max-output-lines nÃ©cessite un nombre"
                fi
                if ! [[ "$2" =~ ^[0-9]+$ ]]; then
                    error "La valeur de --max-output-lines doit Ãªtre un nombre"
                fi
                MAX_OUTPUT_LINES="$2"
                shift 2
                ;;
            --include-agents)
                INCLUDE_AGENTS="true"
                shift
                ;;
            --show-outputs)
                SHOW_OUTPUTS="true"
                shift
                ;;
            *)
                error "Option inconnue: $1. Utilisez -h pour l'aide."
                ;;
        esac
    done
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Main
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
main() {
    check_dependencies
    parse_args "$@"

    # Charger la liste des conversations (compatible bash 3.x)
    local -a conversations=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && conversations+=("$line")
    done < <(list_conversations "$PROJECT_FILTER")

    case "$MODE" in
        list)
            if [[ ${#conversations[@]} -eq 0 ]]; then
                warn "Aucune conversation trouvÃ©e."
                exit 0
            fi
            print_conversation_list "${conversations[@]}"
            ;;
        export)
            if [[ ${#conversations[@]} -eq 0 ]]; then
                error "Aucune conversation trouvÃ©e."
            fi
            if [[ $EXPORT_ID -lt 1 || $EXPORT_ID -gt ${#conversations[@]} ]]; then
                error "NumÃ©ro de conversation invalide: $EXPORT_ID (1-${#conversations[@]})"
            fi
            local idx=$((EXPORT_ID - 1))
            local file
            file=$(echo "${conversations[$idx]}" | cut -d'|' -f1)
            if [[ "$OUTPUT_FORMAT" == "html" ]]; then
                export_conversation_html "$file" "$OUTPUT_FILE" "$WITH_CODE"
            else
                export_conversation "$file" "$OUTPUT_FILE" "$WITH_CODE" "$MAX_OUTPUT_LINES" "$INCLUDE_AGENTS" "$SHOW_OUTPUTS"
            fi
            ;;
        interactive)
            if [[ ${#conversations[@]} -eq 0 ]]; then
                warn "Aucune conversation trouvÃ©e."
                exit 0
            fi
            local selected_file
            # Utiliser fzf si disponible et non dÃ©sactivÃ©
            if [[ "$USE_FZF" != "false" ]] && command -v fzf &>/dev/null; then
                selected_file=$(fzf_select "${conversations[@]}") || exit 0
            else
                selected_file=$(interactive_select "${conversations[@]}") || exit 0
            fi
            if [[ -n "$selected_file" ]]; then
                clear
                if [[ "$OUTPUT_FORMAT" == "html" ]]; then
                    export_conversation_html "$selected_file" "$OUTPUT_FILE" "$WITH_CODE"
                else
                    export_conversation "$selected_file" "$OUTPUT_FILE" "$WITH_CODE" "$MAX_OUTPUT_LINES" "$INCLUDE_AGENTS" "$SHOW_OUTPUTS"
                fi
            fi
            ;;
    esac
}

main "$@"
